#!/usr/bin/env node

/**
 * Muralla CLI - Command interface for Shared State System v2.0
 */

const fs = require('fs').promises;
const fsSync = require('fs');
const path = require('path');
const { spawn } = require('child_process');

class MurallaCLI {
  constructor() {
    this.projectRoot = process.cwd();
    this.stateDir = path.join(this.projectRoot, '.shared-state');
    this.configPath = path.join(this.stateDir, 'config', 'system.json');
    this.todosPath = path.join(this.stateDir, 'todos', 'shared-todos.json');
    this.memoriesPath = path.join(this.stateDir, 'memories');
  }

  async ensureSystem() {
    if (!fsSync.existsSync(this.stateDir)) {
      console.log('‚ùå Muralla Shared State System not initialized');
      console.log('   Run: muralla init');
      process.exit(1);
    }
  }

  async status() {
    await this.ensureSystem();
    
    try {
      // Load system config
      const config = JSON.parse(await fs.readFile(this.configPath, 'utf8'));
      
      // Load active sessions
      const sessionsDir = path.join(this.stateDir, 'sessions');
      const sessionFiles = await fs.readdir(sessionsDir);
      const activeSessions = [];
      
      for (const file of sessionFiles) {
        if (file.endsWith('.json')) {
          const sessionData = JSON.parse(
            await fs.readFile(path.join(sessionsDir, file), 'utf8')
          );
          if (sessionData.status === 'active') {
            activeSessions.push(sessionData);
          }
        }
      }
      
      // Load todos
      let todos = { todos: [], stats: { total: 0, pending: 0, in_progress: 0, completed: 0 } };
      if (fsSync.existsSync(this.todosPath)) {
        todos = JSON.parse(await fs.readFile(this.todosPath, 'utf8'));
      }
      
      // Load recent events
      const eventsDir = path.join(this.stateDir, 'events');
      let recentEvents = [];
      if (fsSync.existsSync(eventsDir)) {
        const eventFiles = await fs.readdir(eventsDir);
        const recentFiles = eventFiles.slice(-5); // Last 5 events
        
        for (const file of recentFiles) {
          if (file.endsWith('.json')) {
            const eventData = JSON.parse(
              await fs.readFile(path.join(eventsDir, file), 'utf8')
            );
            recentEvents.push(eventData);
          }
        }
      }
      
      // Display status
      console.log(`üè∞ Muralla Shared State System v${config.version}`);
      console.log(`üìÅ Project: ${path.basename(this.projectRoot)}`);
      console.log(`‚ö° Status: ${config.initialized ? '‚úÖ Active' : '‚ùå Inactive'}`);
      console.log(``);
      
      console.log(`üîó Active Sessions (${activeSessions.length}):`);
      activeSessions.forEach(session => {
        const uptime = Math.floor((Date.now() - new Date(session.started_at).getTime()) / 60000);
        console.log(`   ‚Ä¢ ${session.session_id.substring(0, 12)}... (${session.ide}) - ${uptime}m`);
      });
      console.log(``);
      
      console.log(`üìã Shared TODOs:`);
      console.log(`   Total: ${todos.stats.total} | Pending: ${todos.stats.pending} | In Progress: ${todos.stats.in_progress} | Completed: ${todos.stats.completed}`);
      console.log(``);
      
      console.log(`üìä Recent Activity (${recentEvents.length} events):`);
      recentEvents.slice(-3).forEach(event => {
        const time = new Date(event.timestamp).toLocaleTimeString();
        console.log(`   ‚Ä¢ ${time} - ${event.type} (${event.session_id?.substring(0, 8)}...)`);
      });
      
    } catch (error) {
      console.error('‚ùå Failed to read system status:', error.message);
      process.exit(1);
    }
  }

  async sessions() {
    await this.ensureSystem();
    
    try {
      const sessionsDir = path.join(this.stateDir, 'sessions');
      const sessionFiles = await fs.readdir(sessionsDir);
      
      console.log(`üîó Muralla Sessions:`);
      console.log(``);
      
      for (const file of sessionFiles) {
        if (file.endsWith('.json')) {
          const sessionData = JSON.parse(
            await fs.readFile(path.join(sessionsDir, file), 'utf8')
          );
          
          const statusIcon = sessionData.status === 'active' ? 'üü¢' : 'üî¥';
          const uptime = sessionData.status === 'active' 
            ? Math.floor((Date.now() - new Date(session.started_at).getTime()) / 60000) + 'm'
            : 'ended';
            
          console.log(`${statusIcon} ${sessionData.session_id}`);
          console.log(`   IDE: ${sessionData.ide}`);
          console.log(`   User: ${sessionData.user}`);
          console.log(`   Started: ${new Date(sessionData.started_at).toLocaleString()}`);
          console.log(`   Uptime: ${uptime}`);
          if (sessionData.project_context) {
            console.log(`   Focus: ${sessionData.project_context.current_focus || 'General'}`);
          }
          console.log(``);
        }
      }
      
    } catch (error) {
      console.error('‚ùå Failed to list sessions:', error.message);
    }
  }

  async todos(action, ...args) {
    await this.ensureSystem();
    
    try {
      let todos = { todos: [], stats: { total: 0, pending: 0, in_progress: 0, completed: 0 } };
      if (fsSync.existsSync(this.todosPath)) {
        todos = JSON.parse(await fs.readFile(this.todosPath, 'utf8'));
      }
      
      switch (action) {
        case 'list':
        case undefined:
          console.log(`üìã Shared TODOs (${todos.stats.total} total):`);
          console.log(``);
          
          todos.todos.forEach(todo => {
            const statusIcon = todo.status === 'completed' ? '‚úÖ' : 
                              todo.status === 'in_progress' ? 'üîÑ' : '‚è≥';
            const priority = todo.priority === 'high' ? 'üî¥' : 
                           todo.priority === 'medium' ? 'üü°' : 'üü¢';
            
            console.log(`${statusIcon} ${priority} ${todo.content}`);
            if (todo.tags && todo.tags.length > 0) {
              console.log(`      Tags: ${todo.tags.join(', ')}`);
            }
            console.log(`      Created: ${new Date(todo.created_at).toLocaleDateString()} by ${todo.created_by}`);
            console.log(``);
          });
          break;
          
        case 'add':
          const content = args.join(' ');
          if (!content) {
            console.log('‚ùå Usage: muralla todos add <todo content>');
            return;
          }
          
          const newTodo = {
            id: `todo_${Date.now()}`,
            content: content,
            status: 'pending',
            activeForm: `Creating: ${content}`,
            priority: 'medium',
            created_at: new Date().toISOString(),
            created_by: 'muralla-cli',
            tags: ['cli']
          };
          
          todos.todos.push(newTodo);
          todos.stats.total++;
          todos.stats.pending++;
          todos.last_updated = new Date().toISOString();
          
          await fs.writeFile(this.todosPath, JSON.stringify(todos, null, 2));
          console.log(`‚úÖ Added TODO: ${content}`);
          break;
          
        case 'complete':
          const todoId = args[0];
          if (!todoId) {
            console.log('‚ùå Usage: muralla todos complete <todo_id>');
            return;
          }
          
          const todo = todos.todos.find(t => t.id === todoId || t.content.includes(todoId));
          if (todo) {
            const oldStatus = todo.status;
            todo.status = 'completed';
            todo.completed_at = new Date().toISOString();
            
            // Update stats
            if (oldStatus === 'pending') todos.stats.pending--;
            if (oldStatus === 'in_progress') todos.stats.in_progress--;
            todos.stats.completed++;
            
            await fs.writeFile(this.todosPath, JSON.stringify(todos, null, 2));
            console.log(`‚úÖ Completed TODO: ${todo.content}`);
          } else {
            console.log(`‚ùå TODO not found: ${todoId}`);
          }
          break;
          
        default:
          console.log('Usage: muralla todos [list|add|complete] [args...]');
      }
      
    } catch (error) {
      console.error('‚ùå Failed to manage todos:', error.message);
    }
  }

  async memories(action, ...args) {
    await this.ensureSystem();
    
    const memoriesIndexPath = path.join(this.memoriesPath, 'index.json');
    
    try {
      await fs.mkdir(this.memoriesPath, { recursive: true });
      
      let memories = { memories: [], last_updated: new Date().toISOString() };
      if (fsSync.existsSync(memoriesIndexPath)) {
        memories = JSON.parse(await fs.readFile(memoriesIndexPath, 'utf8'));
      }
      
      switch (action) {
        case 'list':
        case undefined:
          console.log(`üß† Project Memories (${memories.memories.length} total):`);
          console.log(``);
          
          memories.memories.forEach(memory => {
            console.log(`üìù ${memory.title}`);
            console.log(`   ${memory.description}`);
            console.log(`   Type: ${memory.type} | Created: ${new Date(memory.created_at).toLocaleDateString()}`);
            if (memory.tags && memory.tags.length > 0) {
              console.log(`   Tags: ${memory.tags.join(', ')}`);
            }
            console.log(``);
          });
          break;
          
        case 'add':
          const title = args[0];
          const description = args.slice(1).join(' ');
          
          if (!title || !description) {
            console.log('‚ùå Usage: muralla memories add "<title>" <description>');
            return;
          }
          
          const newMemory = {
            id: `mem_${Date.now()}`,
            title: title,
            description: description,
            type: 'knowledge',
            created_at: new Date().toISOString(),
            created_by: 'muralla-cli',
            tags: ['manual'],
            content: {
              text: description,
              metadata: {}
            }
          };
          
          memories.memories.push(newMemory);
          memories.last_updated = new Date().toISOString();
          
          await fs.writeFile(memoriesIndexPath, JSON.stringify(memories, null, 2));
          
          // Also create individual memory file
          const memoryFile = path.join(this.memoriesPath, `${newMemory.id}.json`);
          await fs.writeFile(memoryFile, JSON.stringify(newMemory, null, 2));
          
          console.log(`üß† Added memory: ${title}`);
          break;
          
        default:
          console.log('Usage: muralla memories [list|add] [args...]');
      }
      
    } catch (error) {
      console.error('‚ùå Failed to manage memories:', error.message);
    }
  }

  async activity(limit = 10) {
    await this.ensureSystem();
    
    try {
      const eventsDir = path.join(this.stateDir, 'events');
      if (!fsSync.existsSync(eventsDir)) {
        console.log('üìä No activity recorded yet');
        return;
      }
      
      const eventFiles = await fs.readdir(eventsDir);
      const recentFiles = eventFiles.slice(-limit);
      
      console.log(`üìä Recent Activity (${recentFiles.length} events):`);
      console.log(``);
      
      for (const file of recentFiles.reverse()) {
        if (file.endsWith('.json')) {
          const eventData = JSON.parse(
            await fs.readFile(path.join(eventsDir, file), 'utf8')
          );
          
          const time = new Date(eventData.timestamp).toLocaleString();
          const sessionId = eventData.session_id?.substring(0, 8) || 'unknown';
          
          console.log(`‚ö° ${time} - ${eventData.type}`);
          console.log(`   Session: ${sessionId}`);
          if (eventData.events && eventData.events.length > 0) {
            console.log(`   Events: ${eventData.events.length}`);
            eventData.events.slice(0, 3).forEach(event => {
              const fileName = event.file_path ? path.basename(event.file_path) : '';
              console.log(`     ‚Ä¢ ${event.type}: ${fileName}`);
            });
          }
          console.log(``);
        }
      }
      
    } catch (error) {
      console.error('‚ùå Failed to show activity:', error.message);
    }
  }

  async watch() {
    await this.ensureSystem();
    
    console.log('üëÄ Watching Muralla Shared State System...');
    console.log('   Press Ctrl+C to stop');
    console.log('');
    
    const eventsDir = path.join(this.stateDir, 'events');
    
    // Watch for new event files
    const chokidar = require('chokidar');
    const watcher = chokidar.watch(eventsDir, { 
      ignored: /^\./,
      persistent: true,
      ignoreInitial: true
    });
    
    watcher.on('add', async (filePath) => {
      try {
        const eventData = JSON.parse(await fs.readFile(filePath, 'utf8'));
        const time = new Date(eventData.timestamp).toLocaleTimeString();
        const sessionId = eventData.session_id?.substring(0, 8) || 'unknown';
        
        console.log(`‚ö° ${time} [${sessionId}] ${eventData.type}`);
        
        if (eventData.events) {
          eventData.events.forEach(event => {
            const fileName = event.file_path ? path.basename(event.file_path) : '';
            console.log(`   ‚Ä¢ ${event.classification || event.change_type}: ${fileName}`);
          });
        }
      } catch (error) {
        // Ignore malformed event files
      }
    });
    
    // Keep watching
    process.stdin.resume();
  }

  async init() {
    console.log('üöÄ Initializing Muralla Shared State System v2.0');
    
    try {
      // Create directory structure
      await fs.mkdir(this.stateDir, { recursive: true });
      const subdirs = ['sessions', 'todos', 'memories', 'logs', 'events', 'config'];
      for (const dir of subdirs) {
        await fs.mkdir(path.join(this.stateDir, dir), { recursive: true });
      }
      
      // Create system config
      const systemConfig = {
        version: '2.0.0',
        name: 'Muralla Shared State System',
        initialized: true,
        created_at: new Date().toISOString(),
        project_root: this.projectRoot,
        features: {
          realtime_sync: true,
          terminal_logs: true,
          ai_tracking: true,
          project_state: true,
          cross_ide: true,
          shared_todos: true,
          shared_memories: true,
          event_driven: true
        },
        sync_interval_ms: 100
      };
      
      await fs.writeFile(this.configPath, JSON.stringify(systemConfig, null, 2));
      
      // Initialize empty todos
      const todosData = {
        version: '1.0.0',
        last_updated: new Date().toISOString(),
        updated_by: 'muralla-init',
        todos: [],
        stats: { total: 0, pending: 0, in_progress: 0, completed: 0 }
      };
      
      await fs.writeFile(this.todosPath, JSON.stringify(todosData, null, 2));
      
      // Create memories index
      const memoriesData = {
        memories: [],
        last_updated: new Date().toISOString()
      };
      
      const memoriesIndexPath = path.join(this.memoriesPath, 'index.json');
      await fs.writeFile(memoriesIndexPath, JSON.stringify(memoriesData, null, 2));
      
      console.log('‚úÖ Muralla Shared State System initialized');
      console.log('');
      console.log('Next steps:');
      console.log('  muralla status    - Check system status');
      console.log('  muralla todos     - Manage shared TODOs');
      console.log('  muralla watch     - Watch real-time activity');
      
    } catch (error) {
      console.error('‚ùå Failed to initialize system:', error.message);
      process.exit(1);
    }
  }
}

// Main CLI handler
async function main() {
  const cli = new MurallaCLI();
  const command = process.argv[2] || 'status';
  const args = process.argv.slice(3);
  
  switch (command) {
    case 'status':
      await cli.status();
      break;
    case 'sessions':
      await cli.sessions();
      break;
    case 'todos':
      await cli.todos(...args);
      break;
    case 'memories':
      await cli.memories(...args);
      break;
    case 'activity':
      await cli.activity(args[0] ? parseInt(args[0]) : 10);
      break;
    case 'watch':
      await cli.watch();
      break;
    case 'init':
      await cli.init();
      break;
    default:
      console.log('Muralla CLI v2.0 - Shared State System');
      console.log('');
      console.log('Commands:');
      console.log('  muralla status                    - Show system status');
      console.log('  muralla sessions                  - List active sessions');
      console.log('  muralla todos [list|add|complete] - Manage shared TODOs');
      console.log('  muralla memories [list|add]       - Manage project memories');
      console.log('  muralla activity [limit]          - Show recent activity');
      console.log('  muralla watch                     - Watch real-time changes');
      console.log('  muralla init                      - Initialize system');
      break;
  }
}

if (require.main === module) {
  main().catch(error => {
    console.error('‚ùå CLI error:', error.message);
    process.exit(1);
  });
}

module.exports = { MurallaCLI };